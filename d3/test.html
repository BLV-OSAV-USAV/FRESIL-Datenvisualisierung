<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Bubble Chart with Treiber Pie Chart</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>
<body>
<script>
    // Set up the SVG container
    const width = window.innerWidth; // Set SVG width dynamically
    const height = window.innerHeight; // Set SVG height dynamically

    const zoom = d3.zoom()
            .scaleExtent([1, 8])
            .on("zoom", zoomed);

    const svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;")
        .attr("text-anchor", "middle")
        .style("cursor", "pointer");

    const packChart = svg.append("g")
        .attr("transform", `translate(-${width / 5},0)`)
        .call(zoom);

    // Load data from CSV files
    Promise.all([
        d3.csv("../figure_data/gefahr_counts.csv"),
        d3.csv("../figure_data/gefahr_treiber_counts.csv")
    ]).then(([gefahrCounts, treiberCounts]) => {
        // Merge the data on 'id' and 'gefahr_id'
        const mergedData = gefahrCounts.map(count => ({
            ...count,
            ...treiberCounts.find(treiber => treiber.gefahr_id === count.id)
        }));

        // Convert the merged data to the desired structure
        const result = mergedData.map(entry => {
            const { id, count, bezeichnung_de, mean_sterne, gefahr_id, ...treiberColumns } = entry;
            const treiber = Object.keys(treiberColumns).reduce((acc, key) => {
                acc[key] = treiberColumns[key];
                return acc;
            }, {});
    
            return {
                id: +id,
                name: bezeichnung_de,
                count: +count,
                mean_sterne: +mean_sterne,
                treiber: treiber
            };
        });
    
        // Create the pack layout.
        const pack = d3.pack()
            .size([width, height])
            .padding(3);
    
        // Compute the hierarchy from the (flat) data; expose the values
        // for each node; lastly, apply the pack layout.
        const root = pack(d3.hierarchy({ children: result })
            .sum(d => d.count));
        // Place each (leaf) node according to the layout’s x and y values.
        const node = packChart.selectAll()
            .data(root.descendants())
            .join("g")
            .attr("transform", d => `translate(${d.x},${d.y})`)
            .on("mouseover", function() { d3.select(this).attr("stroke", "#000"); })
            .on("mouseout", function() { d3.select(this).attr("stroke", null); })
            .on("click", reset);
    
        // Add a title.
        node.append("title")
            .text(d => `${d.data.name}\nMeldung count: ${d.data.count}\nMean sterne: ${d.data.mean_sterne}`);
    
        // Add a filled circle.
        node.append("circle")
            .attr("fill-opacity", 0.4)
            .attr("fill", "white")
            .attr("r", d => d.r);

        const treiberNames = Object.keys(result[0].treiber);
        const customColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
                                 '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', 
                                 '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', 
                                 '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', 
                                 '#f7b6d2', '#c7c7c7', '#dbdb8d'];

        const colorScale = d3.scaleOrdinal()
            .domain(treiberNames)
            .range(customColors);
    
        // Add a pie chart for each gefahr circle.
        node.filter(d => d.depth === 1)  // Filter only circles representing gefahr
            .each(function (d) {
                const hasTreiberData = Object.keys(d.data.treiber).length > 0;
            
                const pie = d3.pie().value(entry => entry.count);
                const arcs = pie(hasTreiberData
                    ? Object.entries(d.data.treiber).map(([key, value]) => ({ name: key, count: value }))
                    : [{ name: 'No Treiber', count: 1 }]); // Default data for pies without treiber
            
                d3.select(this).selectAll("path")
                    .data(arcs)
                    .join("path")
                    .attr("fill", (arc, i) => (hasTreiberData ? colorScale(arc.data.name) : '#FFE5B4'))
                    .attr("d", d3.arc().innerRadius(0).outerRadius(d.r));
            });
    
        // Add a label only if the pie is large enough
        const text = node.append("text")
            .attr("clip-path", d => `circle(${d.r})`);

        // Add a tspan for each word in the label only if the pie is large enough
        text.selectAll()
            .data(d => (d.data.name && d.r > 20 ? d.data.name.split(/\s+/) : [])) // Adjust the threshold (20) as needed
            .join("tspan")
            .attr("x", 0)
            .attr("y", (d, i, nodes) => `${i - nodes.length / 2 + 0.35}em`)
            .text(d => d);

        // Add a tspan for the node’s value.
        text.append("tspan")
            .attr("x", 0)
            .attr("y", d => (d.data.name && d.r > 20 ? `${d.data.name.split(/\s+/).length / 2 + 0.35}em` : "0"))
            .attr("fill-opacity", 0.7)
            .text(d => d.data.count);
            
        // Add a legend
        const maxLegendTextWidth = d3.max(treiberNames, d => d.length);

        const legendWidth = width/3; // Adjust the legend width as needed
        const legendHeight = height - 50; // Adjust the legend height as needed
        const legendX = width - legendWidth - 10; // Adjust the X position
        const legendY = height - legendHeight - 10; // Adjust the Y position

        const legend = svg.append("g")
            .attr("class", "legend")
            .attr("transform", `translate(${legendX},${legendY})`);
                
        const legendRectSize = 18;
        const legendSpacing = 6;
                
        const legendItems = legend.selectAll(".legend-item")
            .data(treiberNames)
            .enter().append("g")
            .attr("class", "legend-item")
            .attr("transform", (d, i) => `translate(0,${i * (legendRectSize + legendSpacing)})`);
                
        legendItems.append("rect")
            .attr("width", legendRectSize)
            .attr("height", legendRectSize)
            .style("fill", d => colorScale(d));
                
        legendItems.append("text")
            .attr("text-anchor", "start")
            .attr("x", legendRectSize + legendSpacing)
            .attr("y", legendRectSize - legendSpacing)
            .text(d => d);

    });

    svg.call(zoom);

    function reset() {
        svg.transition().duration(750).call(
            zoom.transform,
            d3.zoomIdentity,
            d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
        );
    }

    // Replace the existing clicked function with the updated one
    function clicked(event, d) {
        console.log("Clicked Event Triggered");
        
        if (!d) return;
        const [[x0, y0], [x1, y1]] = packChart.node().getBBox();
        event.stopPropagation();

        packChart.selectAll("path") // Select all pie chart paths
            .transition().style("fill", null); // Reset fill for all paths

        d3.select(this).transition().style("fill", "red"); // Highlight the clicked path

        packChart.transition().duration(750).call(
            zoom.transform,
            d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)))
                .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
            d3.pointer(event, packChart.node())
        );
    }


    function zoomed(event) {
        console.log("Zoom Event Triggered");
        if (!event || !event.transform) return;
        const { transform } = event;
        packChart.attr("transform", transform);
        packChart.attr("stroke-width", 1 / transform.k);
    }



</script>
</body>
</html>