<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Bubble Chart with Treiber Pie Chart</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>
<body>

<script>
    // Load data from CSV files
    Promise.all([
        d3.csv("../figure_data/gefahr_counts.csv"),
        d3.csv("../figure_data/gefahr_treiber_counts.csv")
    ]).then(([gefahrCounts, treiberCounts]) => {
        // Merge the data on 'id' and 'gefahr_id'
        console.log(treiberCounts)
        const mergedData = gefahrCounts.map(count => ({
            ...count,
            ...treiberCounts.find(treiber => treiber.gefahr_id === count.id)
        }));
    
        // Convert the merged data to the desired structure
        const result = mergedData.map(entry => {
            const { id, count, bezeichnung_de, mean_sterne, gefahr_id, ...treiberColumns } = entry;
            const treiber = Object.keys(treiberColumns).reduce((acc, key) => {
                acc[key] = treiberColumns[key];
                return acc;
            }, {});
    
            return {
                id: +id,
                name: bezeichnung_de,
                count: +count,
                mean_sterne: +mean_sterne,
                treiber: treiber
            };
        });
    
        // Set up the SVG container
        const width = 1500;
        const height = 600;
    
        const svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;")
            .attr("text-anchor", "middle");
    
        // Create the pack layout.
        const pack = d3.pack()
            .size([width, height])
            .padding(3);
    
        // Compute the hierarchy from the (flat) data; expose the values
        // for each node; lastly, apply the pack layout.
        const root = pack(d3.hierarchy({ children: result })
            .sum(d => d.count));
    
        // Create a group element for the pack layout
        const packChart = svg.append("g")
            .attr("transform", "translate(0,0)");

        // Define the zoomToNode function
        function zoomToNode(clickedNode) {
            const transitionDuration = 750;
    
            // Calculate the new scale and translate values for zooming
            const scale = Math.min(width, height) / (2 * clickedNode.r);
            const translate = [width / 2 - scale * clickedNode.x, height / 2 - scale * clickedNode.y];
    
            // Apply the zoom transformation to the packChart group
            packChart.transition()
                .duration(transitionDuration)
                .attr("transform", `translate(${translate}) scale(${scale})`)
                .on("end", () => {
                    // Hide non-zoomed nodes after the zoom transition is complete
                    node.style("visibility", d => (d === clickedNode || d.ancestors().includes(clickedNode)) ? "visible" : "hidden");
                });
        }
    
        // Place each (leaf) node according to the layout’s x and y values.
        const node = packChart.selectAll()
            .data(root.descendants())
            .join("g")
            .attr("transform", d => `translate(${d.x},${d.y})`)
            .on("click", zoomToNode);  // Add click event listener to zoom on click
    
        // Add a title.
        node.append("title")
            .text(d => `${d.data.name}\nMeldung count: ${d.data.count}\nMean sterne: ${d.data.mean_sterne}`);
    
        // Add a filled circle.
        node.append("circle")
            .attr("fill-opacity", 0.4)
            .attr("fill", "white")
            .attr("r", d => d.r);

        const treiberNames = Object.keys(result[0].treiber);
        const customColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
                                 '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', 
                                 '#bcbd22', '#17becf', '#aec7e8', '#ffbb78', 
                                 '#98df8a', '#ff9896', '#c5b0d5', '#c49c94', 
                                 '#f7b6d2', '#c7c7c7', '#dbdb8d'];

        const colorScale = d3.scaleOrdinal()
            .domain(treiberNames)
            .range(customColors);
    
        // Add a pie chart for each gefahr circle.
        node.filter(d => d.depth === 1)  // Filter only circles representing gefahr
            .each(function (d) {
                const hasTreiberData = Object.keys(d.data.treiber).length > 0;
            
                const pie = d3.pie().value(entry => entry.count);
                const arcs = pie(hasTreiberData
                    ? Object.entries(d.data.treiber).map(([key, value]) => ({ name: key, count: value }))
                    : [{ name: 'No Treiber', count: 1 }]); // Default data for pies without treiber
            
                d3.select(this).selectAll("path")
                    .data(arcs)
                    .join("path")
                    .attr("fill", (arc, i) => (hasTreiberData ? colorScale(arc.data.name) : '#FFE5B4')) // Use the colorScale for pies with treiber, 'gray' for those without
                    .attr("d", d3.arc().innerRadius(0).outerRadius(d.r));
            });
    
        // Add a label only if the pie is large enough
        const text = node.append("text")
            .attr("clip-path", d => `circle(${d.r})`);

        // Add a tspan for each word in the label only if the pie is large enough
        text.selectAll()
            .data(d => (d.data.name && d.r > 20 ? d.data.name.split(/\s+/) : [])) // Adjust the threshold (20) as needed
            .join("tspan")
            .attr("x", 0)
            .attr("y", (d, i, nodes) => `${i - nodes.length / 2 + 0.35}em`)
            .text(d => d);

        // Add a tspan for the node’s value.
        text.append("tspan")
            .attr("x", 0)
            .attr("y", d => (d.data.name && d.r > 20 ? `${d.data.name.split(/\s+/).length / 2 + 0.35}em` : "0"))
            .attr("fill-opacity", 0.7)
            .text(d => d.data.count);
            
        // Add a legend
        const legend = svg.append("g")
            .attr("class", "legend")
            .attr("transform", `translate(${width - 400},${height - 400})`);
                
        const legendRectSize = 18;
        const legendSpacing = 6;
                
        const legendItems = legend.selectAll(".legend-item")
            .data(treiberNames)
            .enter().append("g")
            .attr("class", "legend-item")
            .attr("transform", (d, i) => `translate(0,${i * (legendRectSize + legendSpacing)})`);
                
        legendItems.append("rect")
            .attr("width", legendRectSize)
            .attr("height", legendRectSize)
            .style("fill", d => colorScale(d));
                
        legendItems.append("text")
            .attr("text-anchor", "start")
            .attr("x", legendRectSize + legendSpacing)
            .attr("y", legendRectSize - legendSpacing)
            .text(d => d);

        // Reset zoom when clicking outside the pie chart
        svg.on("click", () => {
            packChart.transition()
                .duration(750)
                .attr("transform", "translate(0,0) scale(1)")
                .on("end", () => {
                    // Make all nodes visible again after the zoom reset
                    node.style("visibility", "visible");
                });
        });

    });
</script>

</body>
</html>
