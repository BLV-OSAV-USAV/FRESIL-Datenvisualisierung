<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Bubble Plot</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <style>
    html, body {
        height: 100%;
        margin: 0;
        padding: 0;
    }
    svg {
        width: 100%;
        height: 100%;
    }
  </style>
</head>
<body>
  <button id="reorganizeButton">Reorganize Circles</button>
  <button id="resetButton">Reset Visualization</button>
  <svg viewBox="-250 -250 500 500"></svg>
  <script>
    Promise.all([
      d3.csv("../figure_data/gefahr_counts.csv"),
      d3.csv("../figure_data/gefahr_treiber_counts.csv")
    ]).then(([gefahrCounts, treiberCounts]) => {
      // Merge the data on 'id' and 'gefahr_id'
      const mergedData = gefahrCounts.map(count => ({
        ...count,
        ...treiberCounts.find(treiber => treiber.gefahr_id === count.id)
      }));
      
<<<<<<< HEAD
      // Store the initial viewBox value
      const initialViewBox = "-250 -250 500 500";
=======
>>>>>>> 8bd44fe6324a88d742e9c7dce71fd44f7af0386e
      

      // Convert the merged data to the desired structure
      const result = mergedData.map(entry => {
        const {
          id,
          count,
          bezeichnung_de,
          mean_sterne,
          gefahr_id,
          ...treiberColumns
        } = entry;
        const treiber = Object.keys(treiberColumns).reduce((acc, key) => {
          acc[key] = treiberColumns[key];
          return acc;
        }, {});
        const size = count * mean_sterne;
        return {
          id: +id,
          name: bezeichnung_de,
          count: +count,
          mean_sterne: +mean_sterne,
          treiber: treiber,
          size: +size
        };
      });

      // Create a force simulation
      const simulation = d3.forceSimulation(result)
        .force("x", d3.forceX().strength(0.05))
        .force("y", d3.forceY().strength(0.05))
        .force("collide", d3.forceCollide(d => d.size + 5).iterations(2))
        .on("tick", ticked);

      function ticked() {
        circles.attr("cx", d => d.x)
          .attr("cy", d => d.y);
      }

      const treiberNames = Object.keys(result[0].treiber);
      const customColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
        '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
        '#bcbd22', '#17becf', '#aec7e8', '#ffbb78',
        '#98df8a', '#ff9896', '#c5b0d5', '#c49c94',
        '#f7b6d2', '#c7c7c7', '#dbdb8d'];

      const colorScale = d3.scaleOrdinal()
        .domain(treiberNames)
        .range(customColors);

      const svg = d3.select("svg");

<<<<<<< HEAD
      let circles = svg.selectAll("circle")
        .data(result)
        .join("circle")
        .attr("r", d => d.size)
        .on("click", zoomToBoundingBox);
    
=======
      const groups = svg.selectAll("g")
      .data(result)
      .join("g")
      .on("click", zoomToBoundingBox);
        
    groups.append("circle")
      .attr("r", d => d.size);
        
    groups.each(function (d) {
      const hasTreiberData = Object.keys(d.treiber).length > 0;
    
      const pie = d3.pie().value(entry => entry.count);
      const arcs = pie(hasTreiberData ?
        Object.entries(d.treiber).map(([key, value]) => ({ name: key, count: value })) :
        [{ name: 'No Treiber', count: 1 }]);
    
      const paths = d3.select(this)
        .selectAll("path")
        .data(arcs)
        .join("path")
        .attr("fill", (arc, i) => (hasTreiberData ? colorScale(arc.data.name) : '#FFE5B4'))
        .attr("d", d3.arc().innerRadius(0).outerRadius(d.size)); // Set your desired radius
    
      paths.each(function (pathData) {
        const pathElement = d3.select(this);
      });
    });
    
    simulation.on("tick", () => {
      groups.attr("transform", d => `translate(${d.x},${d.y})`);
    });
>>>>>>> 8bd44fe6324a88d742e9c7dce71fd44f7af0386e

      // Add this code inside your existing script tag
      document.getElementById('reorganizeButton').addEventListener('click', reorganizeCircles);
      document.getElementById('resetButton').addEventListener('click', resetVisualization);

      function reorganizeCircles() {
        // Sort the result array based on circle size
        result.sort((a, b) => b.size - a.size);

        // Calculate new positions for circles in a spiral layout
        const numCircles = result.length;
        const centerX = 0;
        const centerY = 0;
        const radiusStep = 20; // Adjust the step based on your preference
        let angle = 0;

        result.forEach((circle, index) => {
          const radius = index * radiusStep;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
        
          circle.x = x;
          circle.y = y;
        
          // Increase the angle for the next circle
          angle += 0.1; // Adjust the angle increment based on your preference
        });
      
        // Update the simulation data and restart it
        simulation.nodes(result).alpha(1).restart();
      }



      function resetVisualization() {
        // Reset the positions of circles to their original state

          // Re-add the circles
        circles = svg.selectAll("circle")
          .data(result)
          .join("circle")
          .attr("r", d => d.size)
          .on("click", zoomToBoundingBox);
            
        result.forEach(circle => {
          circle.x = Math.random() * 500 - 250; // Random x position
          circle.y = Math.random() * 500 - 250; // Random y position
        });

        // Reset the forces in the simulation
        simulation.force("x", d3.forceX().strength(0.05))
                  .force("y", d3.forceY().strength(0.05))
                  .force("collide", d3.forceCollide(d => d.size + 5).iterations(2));

        // Update the simulation data and restart it
        simulation.nodes(result).alpha(1).restart();

        // Warm up the simulation
        for (let i = 0; i < 120; i++) {
          simulation.tick();
        }

        // Reset the viewBox to the initial value
        svg.attr("viewBox", initialViewBox);

        // Remove the pie chart and back button if they exist
        svg.select(".pie-chart-group").remove();
        svg.select("text").remove();

        // Re-add the circles
        circles = svg.selectAll("circle")
          .data(result)
          .join("circle")
          .attr("r", d => d.size)
          .on("click", zoomToBoundingBox);
      }

      function zoomToBoundingBox(_, d) {
        const evt = d3.event; // Access the d3 event object directly
        evt.stopPropagation();

        let elem = evt.currentTarget;
        let bbox = elem.getBBox();
        let minX = bbox.x;
        let minY = bbox.y;
        let width = bbox.width + 20;
        let height = bbox.height;
        let viewBox = minX + " " + minY + " " + width + " " + height;

        // Calculate the center of the circle
        let centerX = minX + bbox.width / 4;
        let centerY = minY + bbox.height / 2;

        // Get the data associated with the circle
        const circleData = d3.select(this).data()[0];
        console.log(circleData.treiber)

        // Check if the circle has treiber data
        const hasTreiberData = Object.keys(circleData.treiber).length > 0;

        const pie = d3.pie().value(entry => entry.count);
        const arcs = pie(hasTreiberData ?
                        Object.entries(circleData.treiber).map(([key, value]) => ({ name: key, count: Number(value) })) :
                        [{ name: 'No Treiber', count: 1 }]);

        // Transition to the zoomed view and then draw the pie chart
        svg.transition()
          .duration(1000) // Adjust the duration as needed
          .attr("viewBox", viewBox)
          .on("end", drawPieChart);

      function drawPieChart() {
        // Clear the circles and the pie chart group
        svg.selectAll("circle").remove();
        svg.select(".pie-chart-group").remove();

        const g = svg.append("g")
          .attr("class", "pie-chart-group")
          .attr("transform", `translate(${centerX}, ${centerY})`);

        g.selectAll("path")
          .data(arcs)
          .join("path")
          .attr("fill", (arc, i) => (hasTreiberData ? colorScale(arc.data.name) : '#FFE5B4'))
          .attr("d", d3.arc().innerRadius(0).outerRadius(Math.min(bbox.width, bbox.height) / 2));

        // Split the text into words
        const words = circleData.name.split(' ');

        // Create a text element
        const text = g.append("text")
          .attr("text-anchor", "middle")
          .attr("font-size", "10px");

        // Add each word as a separate tspan, adjusting the dy attribute for line spacing
        words.forEach((word, i) => {
          text.append("tspan")
            .attr("x", 0)
            .attr("dy", i ? "1.2em" : 0) // Adjust for line height
            .text(word);
        });
      }
      }

      svg.on("click", zoomToBoundingBox) // or "pointerdown"
    })
  </script>
</body>

</html>
